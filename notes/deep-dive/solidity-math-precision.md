# Solidity 정수 연산과 정밀도 — 렌딩 프로토콜에서의 실전

> InterestRateModel 구현하면서 배운 Solidity 정수 수학의 핵심 정리

---

## 문제: Solidity에는 소수점이 없다

```
Solidity는 float/double이 존재하지 않는다.
모든 연산은 정수(uint256)로만 처리.

800 / 1000 = 0   ← 0.8이 아님! 소수점 이하 버림
1 / 3 = 0         ← 0.333...이 아님!

→ 이자율 7%를 어떻게 표현? 0.07은 정수로 표현 불가능
```

---

## 해결: PRECISION 스케일링 (1e18)

```
아이디어: 모든 비율을 1e18(= 10^18)을 곱한 정수로 표현

  7%  = 0.07  → 0.07 × 1e18 = 70,000,000,000,000,000 (0.07e18)
  80% = 0.80  → 0.80 × 1e18 = 800,000,000,000,000,000 (0.8e18)

나눗셈도 보존됨:
  800 * 1e18 / 1000 = 800,000,000,000,000,000 (= 0.8e18 = 80%) ✓
  1 * 1e18 / 3      = 333,333,333,333,333,333 (≈ 0.333e18)      ✓
```

### 왜 1e18인가?

```
┌────────────┬──────────────┬─────────────────────┐
│ 프로토콜    │ 스케일        │ 이유                 │
├────────────┼──────────────┼─────────────────────┤
│ Compound   │ 1e18 (Mantissa)│ ETH 기본 단위 (wei) │
│ Aave V3    │ 1e27 (Ray)    │ 더 높은 정밀도 필요  │
│ Uniswap V3 │ 2^96 (Q96)    │ 제곱근 연산 최적화   │
│ 우리 모델   │ 1e18          │ 표준, 충분한 정밀도  │
└────────────┴──────────────┴─────────────────────┘

1e18 = 18자리 소수점 → 일반적인 금융 계산에 충분
```

---

## 3대 원칙

### ① 곱하기를 먼저, 나누기를 나중에

```solidity
// ✅ 올바른 순서: 곱하기 먼저 → 정밀도 보존
uint256 result = tiny * PRECISION / big;
// 1 * 1e18 / 3 = 333,333,333,333,333,333

// ❌ 잘못된 순서: 나누기 먼저 → 정밀도 손실
uint256 result = tiny / big * PRECISION;
// 1 / 3 * 1e18 = 0 * 1e18 = 0  ← 완전 손실!
```

### ② 스케일된 값끼리 곱하면 PRECISION으로 나눠야 함

```solidity
uint256 utilization = 0.8e18;   // 80% (1e18 스케일)
uint256 multiplier  = 0.1e18;   // 10% (1e18 스케일)

// ❌ 잘못: 두 스케일 값을 곱하면 1e36이 됨
uint256 wrong = utilization * multiplier;
// = 8e34 (의미없는 값)

// ✅ 올바른: PRECISION으로 한 번 나눠서 스케일 복원
uint256 correct = utilization * multiplier / PRECISION;
// = 0.08e18 = 8%  (80% × 10% = 8%)
```

### ③ 엣지 케이스 (0 나누기) 먼저 처리

```solidity
function getUtilization(uint256 deposits, uint256 borrows) public pure returns (uint256) {
    if (deposits == 0) return 0;  // 빈 풀
    if (borrows == 0) return 0;   // 대출 없음
    return borrows * PRECISION / deposits;
}
```

---

## 연간 → 초당 변환: 왜 필요한가?

```
렌딩 프로토콜에서 이자는 "1년에 한번"이 아니라
"누군가가 트랜잭션을 보낼 때마다" 불규칙하게 계산된다.

  Block 100:         Alice 대출 (APR 7%)
  Block 100 + 3600초: Bob 예치 → accrueInterest() 호출

  이 1시간 동안의 이자는?

  ❌ 연간 APR 직접 쓰면:
    interest = 10,000 × 7% = 700 USDC ← 1년치를 1시간만에?!

  ✅ 초당 이자율 쓰면:
    ratePerSec = 7% / 31,536,000 = 0.000000002219...
    interest = 10,000 × ratePerSec × 3,600 = 0.08 USDC ← 1시간치만 정확히

LendingPool._accrueInterest() 코드:
  timeElapsed = block.timestamp - lastUpdateTimestamp  // 경과 초
  interest = totalBorrows × ratePerSecond × timeElapsed
```

```
연간 APR = 인간이 읽기 좋은 단위 ("7% 이자")
초당 rate = 컨트랙트가 계산하기 좋은 단위 ("경과초 × 이자율")

Compound V2: 블록당(perBlock) 단위 사용 (blocksPerYear = 2,102,400)
Aave V3 / 우리 모델: 초당(perSecond) 단위 사용 (365 days = 31,536,000)
```

---

## 정밀도 손실은 얼마나 되는가?

### 실측 (MathTest 결과)

```
연간 7% = 0.07e18 = 70,000,000,000,000,000
÷ 31,536,000초     =          2,219,685,438 (초당)
× 31,536,000초     = 69,999,999,972,768,000 (역산)

손실 = 27,232,000 wei

비율 = 27,232,000 / 70,000,000,000,000,000 = 0.0000000389%
```

### 실제 돈으로 환산

```
100만 USDC 풀, 7% APR 기준:
  정밀도 손실 = $1,000,000 × 0.0000000389% = $0.000389 (≈ 0.04센트/년)

10억 USDC 풀 기준에서도:
  정밀도 손실 = $0.389/년 (40센트도 안 됨)

→ 사실상 무시 가능한 수준
```

### 프로토콜별 정밀도 비교

```
┌────────────┬──────────────┬──────────────────────┐
│ 프로토콜    │ 스케일        │ 정밀도 손실 (100만$)  │
├────────────┼──────────────┼──────────────────────┤
│ 우리 모델   │ 1e18         │ ~$0.0004/년           │
│ Aave V3    │ 1e27 (Ray)   │ ~$0.0000000000004/년  │
│ Compound   │ 1e18         │ ~$0.0004/년           │
└────────────┴──────────────┴──────────────────────┘

Aave가 1e27을 쓰는 이유: 정밀도를 9자리 더 확보
대신 overflow 위험이 커지므로 Solidity 0.8+ 자동 체크에 의존
```

---

## 검증 테스트 코드

```
forge test --match-contract MathTest -vvv
  → test_01~06: 정수 나눗셈, PRECISION 스케일링, 곱셈 순서 차이

forge test --match-contract InterestRatePracticeTest -vvv
  → 16개 테스트: utilization, borrowRate, supplyRate 전체 검증
  → compound-v2-scenario.md의 시뮬레이션 표와 숫자 일치 확인
```

---

## 결론

```
1. Solidity에서 비율/이자율은 항상 1e18 스케일로 표현
2. 곱하기 먼저, 나누기 나중에 (mul before div)
3. 스케일 값 × 스케일 값 = PRECISION으로 나눠서 복원
4. 연간 APR → 초당 변환은 불규칙한 이자 계산 때문에 필수
5. 정밀도 손실은 1e18 스케일에서 실질적으로 0에 가까움
```
